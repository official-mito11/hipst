import { resolve, dirname, basename, extname } from "node:path";
import { mkdirSync, writeFileSync } from "node:fs";

function collectParamsFromPattern(pattern: string): string[] {
  const keys: string[] = [];
  const re = /:([A-Za-z0-9_]+)/g;
  let m: RegExpExecArray | null;
  while ((m = re.exec(pattern))) keys.push(m[1]!);
  return keys;
}

export function sanitizeName(method: string, pattern: string): string {
  const cleaned = pattern
    .replace(/^\//, "")
    .replace(/\/:/g, "_")
    .replace(/\//g, "_")
    .replace(/[^A-Za-z0-9_]/g, "_")
    || "root";
  return `${method}_${cleaned}`;
}

function buildTree(root: any): Array<{ method: string; pattern: string; params: string[] }>{
  const out: Array<{ method: string; pattern: string; params: string[] }> = [];
  const stack: any[] = [root];
  function fullPattern(node: any): string {
    const parts: string[] = [];
    let p: any | undefined = node;
    const s: string[] = [];
    while (p) { s.push(p.basePath); p = p.parent; }
    for (let i = s.length - 1; i >= 0; i--) parts.push(s[i]!);
    const j = parts.join("");
    return j || "/";
  }
  const seen = new Set<any>();
  while (stack.length) {
    const n = stack.pop();
    if (!n || seen.has(n)) continue;
    seen.add(n);
    const handlers = (n as any).handlers ?? {};
    const patt = fullPattern(n);
    for (const m of Object.keys(handlers)) {
      out.push({ method: m.toUpperCase(), pattern: patt, params: collectParamsFromPattern(patt) });
    }
    const children: any[] = (n as any).children ?? [];
    for (const ch of children) stack.push(ch);
  }
  return out;
}

function emitHeader(): string {
  return `// GENERATED by hipst codegen on ${new Date().toISOString()}
// Do not edit manually.

export interface RequestOptions { baseUrl?: string; fetchImpl?: typeof fetch }

function joinUrl(base: string | undefined, path: string): string {
  if (!base) return path;
  if (base.endsWith('/')) base = base.slice(0, -1);
  return base + path;
}

function encodeQS(input: Record<string, any> | undefined): string {
  if (!input) return '';
  const sp = new URLSearchParams();
  for (const [k, v] of Object.entries(input)) {
    if (v === undefined || v === null) continue;
    if (Array.isArray(v)) for (const it of v) sp.append(k, String(it));
    else sp.set(k, String(v));
  }
  const s = sp.toString();
  return s ? ('?' + s) : '';
}

function fillPath(pattern: string, params?: Record<string, string | number>): string {
  if (!params) return pattern;
  return pattern.replace(/:([A-Za-z0-9_]+)/g, (_, k) => {
    const v = (params as any)[k];
    if (v === undefined) throw new Error('Missing param: ' + k);
    return encodeURIComponent(String(v));
  });
}

async function parseBody(res: Response): Promise<any> {
  const ct = res.headers.get('content-type') || '';
  if (ct.includes('application/json')) return res.json();
  if (ct.startsWith('text/')) return res.text();
  return res.arrayBuffer();
}
`;
}

function emitEndpoint(fnName: string, method: string, pattern: string, params: string[]): string {
  const paramsType = params.length ? '{ ' + params.map(k => `${k}: string`).join('; ') + ' }' : 'undefined';
  return `
export async function ${fnName}(args?: { params?: ${paramsType}; query?: Record<string, any>; body?: any }, init?: RequestInit, opts?: RequestOptions): Promise<any> {
  const url = joinUrl(opts?.baseUrl, fillPath(${JSON.stringify(pattern)}, args?.params)) + encodeQS(args?.query);
  const fetcher = opts?.fetchImpl || fetch;
  const headers = new Headers(init?.headers || {});
  const hasBody = args && Object.prototype.hasOwnProperty.call(args, 'body');
  let bodyInit: BodyInit | undefined = undefined;
  if (hasBody) {
    const b = (args as any).body;
    if (b instanceof Blob || b instanceof ArrayBuffer || b instanceof FormData || typeof b === 'string' || b instanceof ReadableStream) bodyInit = b as any;
    else { headers.set('Content-Type', headers.get('Content-Type') || 'application/json'); bodyInit = JSON.stringify(b); }
  }
  const res = await fetcher(url, { ...(init || {}), method: ${JSON.stringify(method)}, body: bodyInit, headers });
  if (!res.ok) {
    const txt = await res.text().catch(() => '');
    throw new Error(${JSON.stringify(method)} + ' ' + ${JSON.stringify(pattern)} + ' failed: ' + res.status + ' ' + res.statusText + (txt ? ('\n' + txt) : ''));
  }
  return parseBody(res);
}
`;
}

export async function runCodegen(args: { api: string; out?: string; baseUrl?: string }) {
  const parts = String(args.api).split('#');
  const apiPathRaw = parts[0]!;
  const exportName = parts[1] as string | undefined;
  const apiPath = resolve(process.cwd(), apiPathRaw);
  const mod = await import(apiPath);
  const apiRoot = exportName ? (mod as any)[exportName] : ((mod as any).default ?? Object.values(mod)[0]);
  if (!apiRoot) {
    throw new Error(`Could not resolve ApiComponent export '${exportName || 'default'}' from ${apiPath}`);
  }
  const endpoints = buildTree(apiRoot);
  const outDirOrFile = args.out ? resolve(process.cwd(), args.out) : resolve(process.cwd(), 'dist/client');
  const isFileTarget = !!args.out && /\.(t|j)sx?$/i.test(String(args.out));
  if (!isFileTarget) mkdirSync(outDirOrFile, { recursive: true });
  const base = basename(apiPath, extname(apiPath)).replace(/\.[tj]sx?$/i, '');
  const outFile = isFileTarget ? outDirOrFile : resolve(outDirOrFile, base + '.client.ts');

  let code = '';
  code += emitHeader();
  for (const ep of endpoints) {
    const name = sanitizeName(ep.method, ep.pattern);
    code += emitEndpoint(name, ep.method, ep.pattern, ep.params);
  }
  if (args.baseUrl) {
    code += `\nexport const withBase = (baseUrl: string) => ({\n`;
    for (const ep of endpoints) {
      const name = sanitizeName(ep.method, ep.pattern);
      code += `  ${name}: (args?: Parameters<typeof ${name}>[0], init?: Parameters<typeof ${name}>[1]) => ${name}(args, init, { baseUrl }),\n`;
    }
    code += `});\n`;
  }

  mkdirSync(dirname(outFile), { recursive: true });
  writeFileSync(outFile, code, 'utf-8');
  return outFile;
}
