{
  "version": 3,
  "sources": ["src/core/context.ts", "src/core/util.ts", "src/core/ui/reactive.ts", "src/core/comp.ts", "src/core/ui/comp.ts", "src/core/ui/factory.ts", "src/core/ui/runtime.ts"],
  "sourcesContent": [
    "import type { Component } from \"./comp\";\n\nexport interface Context<C extends Component> {\n  self: C;\n}\n\n// A value that can be a static literal or a function of a context\nexport type ValueOrFn<T, Ctx> = T | ((ctx: Ctx) => T);\n\nexport function resolveValue<T, Ctx>(ctx: Ctx, v: ValueOrFn<T, Ctx>): T {\n  return typeof v === \"function\" ? (v as (c: Ctx) => T)(ctx) : v;\n}\n\nexport type HandleFn<T, C extends Component> = (\n  ctx: Context<C>,\n  value: T\n) => C;",
    "import type { OptionalParam } from \"../types\";\nimport type { Component } from \"./comp\";\nimport { resolveValue, type Context, type HandleFn, type ValueOrFn } from \"./context\";\n\nexport type MethodType<S extends Component, T> = OptionalParam<T> extends true\n  ? <U extends S>(this: U, value?: ValueOrFn<T, Context<U>>) => U\n  : <U extends S>(this: U, value: ValueOrFn<T, Context<U>>) => U;\n\nexport function attachMethod<S extends Component, K extends string, T>(\n  obj: S,\n  name: K,\n  fn: HandleFn<T, S>\n): asserts obj is S & {\n  [P in K]: MethodType<S, T>;\n} {\n  if (name in obj) {\n    throw new Error(`Method ${name} already exists`);\n  }\n  Object.defineProperty(obj, name, {\n    value: (value?: ValueOrFn<T, Context<S>>) => {\n      const ctx = { self: obj } as Context<S>;\n      const resolved = resolveValue(ctx, value as any);\n      return fn(ctx, resolved as T);\n    },\n    writable: true,\n    configurable: true,\n    enumerable: false,\n  });\n}\n\n// Turn an object and a call-implementation into a callable proxy that preserves\n// method chaining semantics. Any method returning the original target will\n// return the proxy instead, enabling fluent APIs.\nexport function toCallable<T extends object, A extends any[], R = T>(\n  target: T,\n  callImpl: (thisObj: T, ...args: A) => R | T\n): T & ((...args: A) => R) {\n  const callable = function (this: any, ...args: A) {\n    const res = callImpl(target, ...args);\n    return (res === target ? proxy : res) as any;\n  } as unknown as T & ((...args: A) => R);\n\n  const handler: ProxyHandler<any> = {\n    get(_t, prop, receiver) {\n      // Allow unwrapping original target from the callable proxy\n      if (prop === \"__hipst_target__\") {\n        return target as any;\n      }\n      // Ensure built-in function machinery works on the callable proxy itself\n      // so accessing .apply/.call/.bind (or function metadata) does not forward to the target object.\n      if (\n        prop === \"apply\" ||\n        prop === \"call\" ||\n        prop === \"bind\" ||\n        prop === \"length\" ||\n        prop === \"name\" ||\n        prop === \"toString\"\n      ) {\n        // Reflect off the underlying callable function, not the target object\n        return Reflect.get(callable as any, prop, receiver);\n      }\n      const v = (target as any)[prop];\n      if (typeof v === \"function\") {\n        // Respect opt-out for wrapping (e.g., state facade proxy)\n        if ((v as any)?.__hipst_no_wrap__) return v;\n        return (...args: unknown[]) => {\n          const out = v.apply(target, args);\n          return out === target ? receiver : out;\n        };\n      }\n      return v;\n    },\n    set(_t, prop, value) {\n      (target as any)[prop] = value;\n      return true;\n    },\n    has(_t, prop) {\n      return prop in target;\n    },\n    ownKeys() {\n      return Reflect.ownKeys(target);\n    },\n    getOwnPropertyDescriptor(_t, prop) {\n      return Object.getOwnPropertyDescriptor(target, prop);\n    },\n  };\n\n  const proxy = new Proxy(callable, handler);\n  return proxy as any;\n}\n\n// Unwrap a callable proxy created by toCallable back to its original target\nexport function unwrap<T = any>(v: any): T {\n  if (v && (typeof v === \"object\" || typeof v === \"function\") && (v as any).__hipst_target__) {\n    return (v as any).__hipst_target__ as T;\n  }\n  return v as T;\n}\n",
    "// Lightweight fine-grained reactivity (track/trigger/effect)\n// Inspired by Vue/Solid patterns, minimal and framework-agnostic\n\ntype DepRef = { depsMap: Map<PropertyKey, Set<Eff>>; key: PropertyKey; set: Set<Eff> };\nexport type Eff = (() => void) & { __deps?: Set<DepRef>; __stopped?: true };\nlet activeEffect: Eff | null = null;\n\nconst bucket = new WeakMap<object, Map<PropertyKey, Set<Eff>>>();\n\nfunction cleanup(eff: Eff) {\n  const deps = eff.__deps;\n  if (!deps) return;\n  for (const ref of deps) {\n    ref.set.delete(eff);\n    if (ref.set.size === 0) ref.depsMap.delete(ref.key);\n  }\n  deps.clear();\n}\n\nexport function effect(fn: () => void): Eff {\n  const runner: Eff = (() => {\n    if ((runner as Eff).__stopped) return;\n    activeEffect = runner;\n    try {\n      cleanup(runner);\n      fn();\n    } finally {\n      activeEffect = null;\n    }\n  }) as Eff;\n  runner.__deps = new Set();\n  // run once to establish dependencies\n  runner();\n  return runner;\n}\n\nexport function stop(eff: Eff) {\n  (eff as Eff).__stopped = true;\n  cleanup(eff as Eff);\n}\n\nexport function track(target: object, key: PropertyKey) {\n  if (!activeEffect) return;\n  let depsMap = bucket.get(target);\n  if (!depsMap) bucket.set(target, (depsMap = new Map()));\n  let dep = depsMap.get(key);\n  if (!dep) depsMap.set(key, (dep = new Set()));\n  dep.add(activeEffect);\n  (activeEffect.__deps ||= new Set()).add({ depsMap, key, set: dep });\n}\n\nexport function trigger(target: object, key: PropertyKey) {\n  const depsMap = bucket.get(target);\n  if (!depsMap) return;\n  const dep = depsMap.get(key);\n  if (!dep) return;\n  // Copy to avoid infinite loops if effects mutate same key during run\n  [...dep].forEach((eff) => { if (!eff.__stopped) eff(); });\n}\n",
    "import type { Context, HandleFn } from \"./context\";\nimport { attachMethod, type MethodType } from \"./util\";\n\nexport class Component {\n  constructor() {\n    const handler: ProxyHandler<Component> = {\n      get(target, prop, receiver) {\n        const original = Reflect.get(target, prop, receiver);\n        if (typeof original === \"function\") {\n          // Respect special callable proxies that should not be wrapped\n          if ((original as any)?.__hipst_no_wrap__) return original;\n          return (...args: unknown[]) => {\n            const result = original.apply(target, args);\n            return result === target ? receiver : result;\n          };\n        }\n        return original;\n      },\n    };\n    return new Proxy(this, handler);\n  }\n\n  handle<T, K extends string, S extends Component>(\n    this: S,\n    name: K,\n    fn: HandleFn<T, S>\n  ): S & { [P in K]: MethodType<S, T> } {\n    attachMethod(this, name, fn);\n    return this;\n  }\n}\n",
    "import type { Properties as CSSProps } from \"csstype\";\nimport { Component } from \"../comp\";\nimport type { ValueOrFn } from \"../context\";\nimport { resolveValue } from \"../context\";\nimport { unwrap, toCallable } from \"../util\";\nimport type { UIContext, PropsCtx } from \"./context\";\nimport { track, trigger } from \"./reactive\";\nimport type { MethodType } from \"../util\";\n\ntype CSSProperties = CSSProps<string | number>;\n\n// A callable component where children value functions receive the full UIContext.\n// The parent in the context is refined to the provided generic `P` for better type inference via parentTyped().\nexport type WithCallable<C extends UIComponent<any, any, any>, P = UIComponent<any, any, any>> = C & {\n  (\n    ...children: Array<\n      | string\n      | UIComponent<any, any, any>\n      | ValueOrFn<string, UIContext<C, StateOf<C>, PropsOf<C>> & { parent?: P }>\n    >\n  ): C;\n  // Fallback overload to support define() call-time arguments that are not strictly children\n  // Example: const Checkbox = ui('input').define(...); Checkbox(true)\n  (...args: any[]): C;\n};\n\ntype StateProps<S extends object> = { [K in keyof S]: S[K] };\ntype WithState<C extends UIComponent<any, any, any>, NS extends object> = C extends UIComponent<infer TG, any, infer PP>\n  ? UIComponent<TG, NS, PP>\n  : UIComponent<any, NS, any>;\ntype WithProps<C extends UIComponent<any, any, any>, NP extends object> = C extends UIComponent<infer TG, infer SS, any>\n  ? UIComponent<TG, SS, NP>\n  : UIComponent<any, any, NP>;\n// Map current prop keys to chainable methods so all previously defined props remain available on the type\n// Only materialize prop methods for literal keys. If P is wide (e.g., Record<string, unknown>), produce none.\ntype PropKeySet<P extends object> = string extends keyof P ? never : keyof P & string;\ntype PropMethods<Tag extends string, S extends object, P extends object> = {\n  [K in PropKeySet<P>]: (\n    value?: ValueOrFn<P[K], UIContext<UIComponent<Tag, S, P>, S, P>>\n  ) => WithCallable<UIComponent<Tag, S, P>> & PropMethods<Tag, S, P>\n};\n\n// Helpers to extract generics from a UIComponent type\ntype TagOf<C extends UIComponent<any, any, any>> = C extends UIComponent<infer TG, any, any> ? TG : string;\ntype StateOf<C extends UIComponent<any, any, any>> = C extends UIComponent<any, infer SS, any> ? SS : {};\ntype PropsOf<C extends UIComponent<any, any, any>> = C extends UIComponent<any, any, infer PP> ? PP : {};\n\n// Derive DOM element and event map from Tag using lib.dom.d.ts\nexport type ElementFromTag<T extends string> =\n  T extends keyof HTMLElementTagNameMap ? HTMLElementTagNameMap[T] :\n  T extends keyof SVGElementTagNameMap ? SVGElementTagNameMap[T] : Element;\n\ntype EventMapFor<T extends string> =\n  T extends keyof HTMLElementTagNameMap ? HTMLElementEventMap :\n  T extends keyof SVGElementTagNameMap ? SVGElementEventMap : GlobalEventHandlersEventMap;\n// Typed, non-recursive state facade: callable + key accessors, refined return type for chaining\nexport type StateFacade<C extends UIComponent<any, any, any>, S extends object> = {\n  <K extends keyof S & string>(key: K, value: S[K]): WithCallable<C> & PropMethods<TagOf<C>, StateOf<C>, PropsOf<C>>;\n  <K extends string, V>(key: K, value: V): WithCallable<WithState<C, S & { [P in K]: V }>> & PropMethods<TagOf<C>, S & { [P in K]: V }, PropsOf<C>>;\n  <T extends Record<string, any>>(obj: T): WithCallable<WithState<C, S & T>> & PropMethods<TagOf<C>, S & T, PropsOf<C>>;\n} & StateProps<S> & { [key: string]: unknown };\n\nexport class UIComponent<Tag extends string = string, S extends object = {}, P extends object = {}> extends Component {\n  private _tag: Tag;\n  private _stateStore: Record<string, unknown> = {};\n  private _propsStore: Record<string, unknown> = {};\n  private _stylesStore: CSSProperties = {};\n  private _attrsStore: Record<string, unknown> = {};\n  private _stateProxy?: StateFacade<UIComponent<Tag, S, P>, S>;\n  private _propsProxy?: PropsCtx<P>;\n  private _children: Array<string | UIComponent<any, any, any> | ValueOrFn<string, any>> = [];\n  private _callArgs?: unknown[];\n  private _effects?: Array<(ctx: UIContext<UIComponent<Tag, S, P>, S, P>) => void>;\n  private _events: Record<string, Array<(ctx: any, ev?: Event) => unknown>> = {};\n  private _parent?: UIComponent<any, any>;\n  private _root?: UIComponent<any, any>;\n\n  constructor(tag: Tag) {\n    super();\n    this._tag = tag;\n  }\n\n  // identity & structure\n  public get tag() { return this._tag; }\n  public get parent() { return this._parent; }\n  public set parent(p: UIComponent<any, any> | undefined) { this._parent = p; }\n  public get root() { return this._root; }\n  public set root(r: UIComponent<any, any> | undefined) { this._root = r; }\n  public get children() { return this._children; }\n\n  // Context-aware reactive state facade: callable for init, property get/set for reactive access\n  public get state(): StateFacade<UIComponent<Tag, S, P>, S> {\n    if (!this._stateProxy) {\n      this._stateProxy = this.createStateFacade();\n    }\n    return this._stateProxy as StateFacade<UIComponent<Tag, S, P>, S>;\n  }\n  public get props(): PropsCtx<P> {\n    if (!this._propsProxy) {\n      this._propsProxy = this.createPropsFacade();\n    }\n    return this._propsProxy as PropsCtx<P>;\n  }\n  public get styles() { return this._stylesStore; }\n  public get attributes() { return this._attrsStore; }\n\n  // Helpers\n  private uiCtx(): UIContext<this, S, P> {\n    return {\n      self: this,\n      parent: this._parent,\n      root: this._root,\n      element: undefined,\n      state: this.state as unknown as import(\"./context\").StateCtx<S>,\n      props: this.props as any,\n      styles: this._stylesStore as this[\"styles\"],\n      attributes: this._attrsStore as this[\"attributes\"],\n      children: (this as any)._callArgs ?? [],\n    };\n  }\n\n  // Composition\n  public append(\n    ...kids: Array<\n      | string\n      | UIComponent<any, any, any>\n      | ValueOrFn<string, UIContext<this, S, P>>\n    >\n  ): this {\n    for (const k of kids) {\n      const real = unwrap(k);\n      if (real instanceof UIComponent) {\n        // cast through unknown to avoid generic variance issues on `state`\n        real.parent = this as unknown as UIComponent<any, any>;\n        const root = this._root ?? this.findRoot();\n        real.root = root as unknown as UIComponent<any, any> | undefined;\n        this._children.push(real);\n      } else {\n        // Ignore uninvoked factories so they don't render as text ValueOrFn\n        if (typeof k === \"function\" && (k as any).__hipst_factory__) {\n          continue;\n        }\n        this._children.push(k);\n      }\n    }\n    // reactive children list\n    trigger((this as any)._children, \"__list__\");\n    return this;\n  }\n\n  public nth(i: number): UIComponent<any, any, any> | undefined {\n    const k = this._children[i];\n    return k instanceof UIComponent ? k : undefined;\n  }\n\n  /**\n   * Initialize multiple state keys with strong typing and refine this component's state shape.\n   * Example: ui(\"div\").stateInit({ count: 0 }) => ctx.state.count inferred as number\n   */\n  public stateInit<T extends object>(obj: T): WithCallable<UIComponent<Tag, S & T>> & PropMethods<Tag, S & T, P> {\n    Object.assign(this._stateStore, obj);\n    for (const k in obj) trigger((this as any)._stateStore, k);\n    return (this as any).__hipst_callable__ as any;\n  }\n\n  /**\n   * Refine this component's state type without mutating runtime state. Useful for declaring shape.\n   */\n  public typed<T extends Record<string, any>>(): WithCallable<UIComponent<Tag, S & T>> & PropMethods<Tag, S & T, P> {\n    return (this as any).__hipst_callable__ as any;\n  }\n\n  /**\n   * Hint the expected parent type for children value functions. This helps TypeScript\n   * infer `parent.state` shape inside child lambdas, e.g.:\n   * ui(\"button\").parentTyped<{ count: number }>()(({ parent }) => parent!.state.count.toFixed(0))\n   */\n  public parentTyped<PS extends object>(): WithCallable<UIComponent<Tag, S>, UIComponent<any, PS>> & PropMethods<Tag, S, P> {\n    return (this as any).__hipst_callable__ as any;\n  }\n\n  // State / Attributes / Styles\n  public attr<T = unknown>(key: string, value: ValueOrFn<T, UIContext<this, S, P>>): this {\n    this._attrsStore[key] = value as any;\n    trigger(this._attrsStore, \"__keys__\");\n    trigger(this._attrsStore, key);\n    return this;\n  }\n\n  public style<K extends keyof CSSProperties>(key: K, value: ValueOrFn<NonNullable<CSSProperties[K]>, UIContext<this, S, P>>): this;\n  public style(obj: Partial<CSSProperties>): this;\n  public style(arg1: keyof CSSProperties | Partial<CSSProperties>, arg2?: ValueOrFn<unknown, UIContext<this, S, P>>): this {\n    if (typeof arg1 === \"object\") {\n      Object.assign(this._stylesStore, arg1);\n      for (const k of Object.keys(arg1)) trigger(this._stylesStore, k);\n      trigger(this._stylesStore, \"__keys__\");\n    } else {\n      (this._stylesStore as any)[arg1] = arg2 as any;\n      trigger(this._stylesStore, arg1);\n      // Also notify key observers so runtime effects can pick up newly added keys\n      trigger(this._stylesStore, \"__keys__\");\n    }\n    return this;\n  }\n\n  // Common shorthands\n  public id(v: ValueOrFn<string, UIContext<this, S, P>>): this { return this.attr(\"id\", v); }\n  public className(v: ValueOrFn<string, UIContext<this, S, P>>): this { return this.attr(\"class\", v); }\n  /**\n   * Alias for setting class attribute. Prefer using classes()/class() for class-first styling.\n   */\n  public class(v: ValueOrFn<string, UIContext<this, S, P>>): this { return this.attr(\"class\", v); }\n  /**\n   * Apply classes from string | string[] | Record<string, boolean>.\n   * Example:\n   *  .classes([\"btn\", ({state})=> state.on && \"on\"]) or .classes({ btn: true, on: ({state})=> state.on })\n   */\n  public classes(v: ValueOrFn<string | string[] | Record<string, any>, UIContext<this, S, P>>): this {\n    return this.attr(\"class\", (ctx: UIContext<this, S, P>) => {\n      const raw = typeof v === \"function\" ? (v as any)(ctx) : v;\n      if (Array.isArray(raw)) return raw.filter(Boolean).map(String).join(\" \");\n      if (raw && typeof raw === \"object\") {\n        const out: string[] = [];\n        for (const [k, val] of Object.entries(raw)) {\n          const vv = typeof val === \"function\" ? (val as any)(ctx) : val;\n          if (vv) out.push(k);\n        }\n        return out.join(\" \");\n      }\n      return String(raw ?? \"\");\n    });\n  }\n  // Simple attribute helpers (no conditional restrictions to avoid deep generic instantiation)\n  public htmlFor(v: ValueOrFn<string, UIContext<this, S, P>>): this { return this.attr(\"for\", v as any); }\n  public type(v: ValueOrFn<string, UIContext<this, S, P>>): this { return this.attr(\"type\", v as any); }\n  public checked(v: ValueOrFn<boolean, UIContext<this, S, P>>): this { return this.attr(\"checked\", v as any); }\n  public value(v: ValueOrFn<string | number, UIContext<this, S, P>>): this { return this.attr(\"value\", v as any); }\n\n  public display(v: ValueOrFn<CSSProperties[\"display\"], UIContext<this, S, P>>): this { return this.style(\"display\", v as any); }\n  public flexDirection(v: ValueOrFn<CSSProperties[\"flexDirection\"], UIContext<this, S, P>>): this { return this.style(\"flexDirection\", v as any); }\n  public flexCol(): this { return this.display(\"flex\").flexDirection(\"column\"); }\n  public flexRow(): this { return this.display(\"flex\").flexDirection(\"row\"); }\n  public p(v: ValueOrFn<string | number, UIContext<this, S, P>>): this;\n  public p(px: string | number | ValueOrFn<string | number, UIContext<this, S, P>>): this {\n    if (typeof px === \"function\") {\n      return this.style(\"padding\", (ctx: UIContext<this, S, P>) => {\n        const out = (px as (c: UIContext<this, S, P>) => string | number)(ctx);\n        return typeof out === \"number\" ? `${out}px` : out;\n      });\n    }\n    return this.style({ padding: typeof px === \"number\" ? `${px}px` : px });\n  }\n  public m(v: ValueOrFn<string | number, UIContext<this, S, P>>): this {\n    if (typeof v === \"function\") {\n      return this.style(\"margin\", (ctx: UIContext<this, S, P>) => {\n        const out = (v as (c: UIContext<this, S, P>) => string | number)(ctx);\n        return typeof out === \"number\" ? `${out}px` : out;\n      });\n    }\n    return this.style({ margin: typeof v === \"number\" ? `${v}px` : v });\n  }\n  public textCenter(): this { return this.style({ textAlign: \"center\" }); }\n\n  // Events (stored only) – typed per Tag using standard DOM event maps\n  public on<K extends keyof EventMapFor<Tag>>(type: K, fn: (ctx: UIContext<this, S, P>, ev: EventMapFor<Tag>[K]) => unknown): this;\n  public on(type: string, fn: (ctx: UIContext<this, S, P>, ev: Event) => unknown): this {\n    (this._events[type] ||= []).push(fn as unknown as (ctx: UIContext<UIComponent<any, any, any>, any, any>, ev?: Event) => unknown);\n    return this;\n  }\n\n  public onClick(fn: (ctx: UIContext<this, S, P>, ev: MouseEvent) => unknown): this {\n    return this.on(\"click\", fn as (c: UIContext<this, S, P>, e: MouseEvent) => unknown);\n  }\n\n  /**\n   * Register a reactive side-effect that runs with UIContext. It returns void and is cleaned up on unmount.\n   */\n  public effect(fn: (ctx: UIContext<this, S, P>) => void): this {\n    (this as any)._effects ||= [];\n    (this as any)._effects.push(fn as any);\n    return this;\n  }\n\n  /**\n   * Define a custom call handler for this component while preserving children-call syntax.\n   * Example:\n   *  const Checkbox = ui('input').type('checkbox').define(({ self }, checked?: boolean) => self.attr('checked', !!checked))\n   *  Checkbox(true) // -> sets checked\n   *  Checkbox(ui('span')(\"label\")) // -> appends children\n   */\n  public define(\n    invoker: (ctx: UIContext<this, S, P>) => this\n  ): (WithCallable<UIComponent<Tag, S, P>> & PropMethods<Tag, S, P>) & ((...args: any[]) => WithCallable<UIComponent<Tag, S, P>> & PropMethods<Tag, S, P>) {\n    const self = this as UIComponent<Tag, S, P>;\n    // Expose invoker on instance so blueprint-based cloning can preserve call-time behavior\n    (self as any).__hipst_invoker__ = invoker as any;\n    const flatten = (arr: any[]): any[] => {\n      const out: any[] = [];\n      for (const a of arr) {\n        if (Array.isArray(a)) out.push(...flatten(a)); else out.push(a);\n      }\n      return out;\n    };\n    const callable = toCallable<UIComponent<Tag, S, P>, any[], UIComponent<Tag, S, P>>(self, (s, ...args: any[]) => {\n      // Rewrapping semantics: capture call-time args as ctx.children and invoke user invoker.\n      (s as any)._callArgs = flatten(args);\n      trigger((s as any), \"__call_args__\");\n      const ctx = (s as any).uiCtx() as UIContext<UIComponent<Tag, S, P>, S, P>;\n      (invoker as any)(ctx);\n      return s;\n    });\n    // Ensure other helpers (e.g., state facade) return the new callable\n    (self as any).__hipst_callable__ = callable;\n    return callable as unknown as (WithCallable<UIComponent<Tag, S, P>> & PropMethods<Tag, S, P>) & ((...args: any[]) => WithCallable<UIComponent<Tag, S, P>> & PropMethods<Tag, S, P>);\n  }\n\n  // Define a custom chainable method (fluent interface) using UIContext\n  // Overloads to infer optional argument if handler's value parameter is optional\n  public prop<K extends string, T = unknown>(\n    name: K,\n    fn: (ctx: UIContext<this, S, P>, value?: T) => this\n  ): WithCallable<UIComponent<Tag, S, P & Record<K, T>>> & PropMethods<Tag, S, P & Record<K, T>>;\n  public prop<K extends string, T = unknown>(\n    name: K,\n    fn: (ctx: UIContext<this, S, P>, value: T) => this\n  ): WithCallable<UIComponent<Tag, S, P & Record<K, T>>> & PropMethods<Tag, S, P & Record<K, T>>;\n  public prop<K extends string, T = unknown>(\n    name: K,\n    fn: (ctx: UIContext<this, S, P>, value: T | undefined) => this\n  ): WithCallable<UIComponent<Tag, S, P & Record<K, T>>> & PropMethods<Tag, S, P & Record<K, T>> {\n    if ((this as any)[name]) {\n      throw new Error(`Method ${String(name)} already exists`);\n    }\n    // Persist handler definition so blueprint clones can reattach methods bound to the new instance\n    const defs = ((this as any).__hipst_prop_defs__ ||= {});\n    defs[String(name)] = fn;\n    Object.defineProperty(this, name, {\n      // Accept optional value at runtime; compile-time optionality comes from overloads/MethodType\n      value: (value?: ValueOrFn<T, UIContext<this, S, P>>) => {\n        // Persist raw prop value for cross-prop referencing via ctx.props\n        (this as any)._propsStore[String(name)] = value as unknown;\n        trigger((this as any)._propsStore, String(name));\n        const ctx = this.uiCtx();\n        const resolved = resolveValue(ctx, value as any);\n        return fn(ctx, resolved as T);\n      },\n      writable: true,\n      configurable: true,\n      enumerable: false,\n    });\n    return (this as any).__hipst_callable__ as any;\n  }\n\n  private findRoot(): this | undefined {\n    let p: this | undefined = this;\n    while (p && p.parent) p = p.parent as this;\n    return p;\n  }\n\n  private createStateFacade() {\n    const self = this as UIComponent<Tag, S, P>;\n    // callable initializer\n    const init = function (this: unknown, keyOrObj: unknown, value?: unknown) {\n      if (keyOrObj && typeof keyOrObj === \"object\" && !Array.isArray(keyOrObj)) {\n        const obj = keyOrObj as Record<string, unknown>;\n        for (const k of Object.keys(obj)) {\n          (self as any)._stateStore[k] = obj[k];\n          trigger((self as any)._stateStore, k);\n        }\n      } else {\n        const k = String(keyOrObj as any);\n        (self as any)._stateStore[k] = value;\n        trigger((self as any)._stateStore, k);\n      }\n      // return the component instance for chaining; Component proxy will map to receiver\n      return self as any;\n    } as unknown as StateFacade<UIComponent<Tag, S, P>, S>;\n    // wrap with proxy to support property get/set reactivity\n    const proxy: any = new Proxy(init, {\n      get(_t, prop: any, _r) {\n        // Preserve function properties (name, length, bind, etc.)\n        const fnVal = Reflect.get(init as any, prop, _r);\n        if (fnVal !== undefined) return fnVal;\n        if (typeof prop === \"string\") {\n          track((self as any)._stateStore, prop);\n          const raw = (self as any)._stateStore[prop];\n          const ctx: UIContext<UIComponent<Tag, S, P>, S, P> = {\n            self,\n            parent: self.parent,\n            root: self.root,\n            element: undefined,\n            state: proxy as any,\n            props: self.props as any,\n            styles: (self as any)._stylesStore as any,\n            attributes: (self as any)._attrsStore as any,\n            children: ((self as any)._callArgs ?? []) as unknown[],\n          } as any;\n          return resolveValue(ctx, raw as any);\n        }\n        return undefined as any;\n      },\n      set(_t, prop: any, value: any) {\n        if (typeof prop !== \"string\") return Reflect.set(init as any, prop, value);\n        const old = (self as any)._stateStore[prop];\n        (self as any)._stateStore[prop] = value;\n        if (old !== value) trigger((self as any)._stateStore, prop);\n        return true;\n      },\n      deleteProperty(_t, prop: any) {\n        if (typeof prop !== \"string\") return Reflect.deleteProperty(init as any, prop);\n        const ok = delete (self as any)._stateStore[prop];\n        trigger((self as any)._stateStore, prop);\n        return ok;\n      },\n      apply(_t, _thisArg, args: any[]) {\n        // allow calling as function: state(key, value) OR state({ ...obj })\n        const [arg1, arg2] = args as [any, any];\n        if (arg1 && typeof arg1 === \"object\" && !Array.isArray(arg1)) {\n          for (const k of Object.keys(arg1)) {\n            (self as any)._stateStore[k] = arg1[k];\n            trigger((self as any)._stateStore, k);\n          }\n        } else {\n          (self as any)._stateStore[arg1] = arg2;\n          trigger((self as any)._stateStore, arg1);\n        }\n        return (self as any).__hipst_callable__ ?? (self as any);\n      },\n    });\n    // prevent higher-level wrapping (Component/toCallable) from overriding proxy behavior\n    proxy.__hipst_no_wrap__ = true;\n    return proxy;\n  }\n\n  private createPropsFacade() {\n    const self = this as UIComponent<Tag, S, P>;\n    const proxy: any = new Proxy({}, {\n      get(_t, prop: any, _r) {\n        if (typeof prop !== \"string\") return undefined as any;\n        track((self as any)._propsStore, prop);\n        const raw = (self as any)._propsStore[prop];\n        const ctx: UIContext<UIComponent<Tag, S, P>, S, P> = {\n          self,\n          parent: self.parent,\n          root: self.root,\n          element: undefined,\n          state: self.state as any,\n          props: proxy as any,\n          styles: (self as any)._stylesStore as any,\n          attributes: (self as any)._attrsStore as any,\n          children: ((self as any)._callArgs ?? []) as unknown[],\n        } as any;\n        return resolveValue(ctx, raw as any);\n      },\n      set(_t, prop: any, value: any) {\n        if (typeof prop !== \"string\") return Reflect.set({}, prop, value);\n        const old = (self as any)._propsStore[prop];\n        (self as any)._propsStore[prop] = value;\n        if (old !== value) trigger((self as any)._propsStore, prop);\n        return true;\n      },\n      deleteProperty(_t, prop: any) {\n        if (typeof prop !== \"string\") return false;\n        const ok = delete (self as any)._propsStore[prop];\n        trigger((self as any)._propsStore, prop);\n        return ok;\n      },\n    });\n    // prevent higher-level wrapping\n    proxy.__hipst_no_wrap__ = true;\n    return proxy as PropsCtx<P>;\n  }\n}\n",
    "import { toCallable } from \"../util\";\nimport { trigger } from \"./reactive\";\nimport { UIComponent, type WithCallable } from \"./comp\";\nimport type { UIContext } from \"./context\";\nimport type { ValueOrFn } from \"../context\";\n\nexport class HtmlRoot extends UIComponent<\"__html_root__\"> {\n  private _title?: ValueOrFn<string, UIContext<this>>;\n  private _metas: Record<string, ValueOrFn<string, UIContext<this>>> = {};\n  private _css: string[] = [];\n\n  constructor() {\n    super(\"__html_root__\");\n    this.root = this;\n  }\n\n  title(v: ValueOrFn<string, UIContext<this>>): this {\n    this._title = v;\n    return this;\n  }\n\n  meta(name: string, content: ValueOrFn<string, UIContext<this>>): this {\n    this._metas[name] = content;\n    return this;\n  }\n\n  /**\n   * Declare a CSS file to be included by the client runtime bundle when CSR is enabled.\n   * The path should be resolvable from the project root (absolute or relative).\n   */\n  css(path: string): this {\n    if (path) this._css.push(path);\n    return this;\n  }\n\n  get headTitle() { return this._title; }\n  get headMetas() { return this._metas; }\n  get headCss() { return this._css.slice(); }\n}\n\nfunction flatten<T>(arr: T[]): T[] {\n  const out: T[] = [];\n  for (const a of arr as any) {\n    if (Array.isArray(a)) out.push(...flatten(a));\n    else out.push(a);\n  }\n  return out;\n}\n\n// Overloads leverage lib.dom.d.ts so tag names are inferred and validated\nexport function ui<K extends keyof HTMLElementTagNameMap>(tag: K): WithCallable<UIComponent<K>>;\nexport function ui<K extends keyof SVGElementTagNameMap>(tag: K): WithCallable<UIComponent<K>>;\nexport function ui<Tag extends string>(tag: Tag): WithCallable<UIComponent<Tag>>;\nexport function ui(tag: string): WithCallable<UIComponent<string>> {\n  const base = new UIComponent<string>(tag as string);\n  const callable = toCallable<UIComponent<string>, any[], UIComponent<string>>(base, (self, ...children: any[]) => {\n    const kids = flatten(children);\n    (self as UIComponent<any>).append(...kids as any);\n    return self;\n  });\n  // keep a back ref for methods that need to return the callable proxy (e.g., state facade)\n  (base as any).__hipst_callable__ = callable;\n  return callable;\n}\n\nexport function html(): WithCallable<HtmlRoot> {\n  const base = new HtmlRoot();\n  const callable = toCallable<HtmlRoot, any[], HtmlRoot>(base, (self, ...children: any[]) => {\n    const kids = flatten(children);\n    (self as UIComponent<any>).append(...kids as any);\n    return self;\n  });\n  (base as any).__hipst_callable__ = callable;\n  return callable;\n}\n\n/**\n * Create a single-call factory component from a builder or a ui() blueprint.\n * Usage:\n *  const Text1 = component(() => ui('span').class('txt'));\n *  const Text2 = component(ui('span').class('txt'));\n *  html()(Text1('hello'), Text2())\n */\nexport function component<F extends WithCallable<UIComponent<any, any, any>> & Record<string, any>>(\n  builder: () => F\n): F;\n\n// Overload: component(ui('div')) – simpler blueprint-based factory\nexport function component<F extends WithCallable<UIComponent<any, any, any>> & Record<string, any>>(\n  template: F\n): F;\n\n// Implementation union\nexport function component<F extends WithCallable<UIComponent<any, any, any>> & Record<string, any>>(\n  arg: any\n): F {\n  type ApplyFn = (instCallable: F) => F;\n\n  const isTemplate = arg && typeof arg === \"function\" && (arg as any).__hipst_target__ instanceof UIComponent;\n  const templateCallable: F | null = isTemplate ? (arg as F) : null;\n  const builder: (() => F) | null = isTemplate ? null : (arg as () => F);\n\n  // Get a sample callable to introspect available methods for Proxy forwarding\n  const sampleCallable: F = templateCallable ?? (builder!() as F);\n  const sampleTarget = (sampleCallable as any).__hipst_target__ as UIComponent<any, any, any>;\n\n  const cloneFromTemplate = (): F => {\n    const tmpl = templateCallable ? ((templateCallable as any).__hipst_target__ as UIComponent<any, any, any>) : sampleTarget;\n    const base = new UIComponent<string>(tmpl.tag as string) as UIComponent<any, any, any>;\n\n    // Copy runtime stores (shallow) – state, props (raw), styles, attributes, events\n    Object.assign((base as any)._stateStore, (tmpl as any)._stateStore);\n    Object.assign((base as any)._propsStore, (tmpl as any)._propsStore);\n    Object.assign((base as any)._stylesStore, (tmpl as any)._stylesStore);\n    Object.assign((base as any)._attrsStore, (tmpl as any)._attrsStore);\n    const evs = (tmpl as any)._events || {};\n    for (const k of Object.keys(evs)) {\n      (base as any)._events[k] = [...(evs[k] as any[])];\n    }\n\n    // Rebuild custom prop methods from definitions to bind to the new instance\n    const defs = (tmpl as any).__hipst_prop_defs__ as Record<string, Function> | undefined;\n    if (defs) {\n      for (const [name, fn] of Object.entries(defs)) {\n        (base as any).prop(name, fn as any);\n      }\n    }\n\n    // Preserve define() call-time semantics if any (rewrapping: args are exposed via ctx.children)\n    const inv = (tmpl as any).__hipst_invoker__ as ((ctx: UIContext<any, any, any>) => any) | undefined;\n    const callable = inv\n      ? toCallable(base, (s: UIComponent<any, any, any>, ...args: any[]) => {\n          // Rewrapping define: capture args for ctx.children and invoke user invoker.\n          const kids = flatten(args);\n          (s as any)._callArgs = kids;\n          // signal reactive consumers of ctx.children\n          trigger((s as any), \"__call_args__\");\n          const ctx = (s as any).uiCtx();\n          (inv as any)(ctx);\n          return s;\n        })\n      : toCallable(base, (self: UIComponent<any, any, any>, ...children: any[]) => {\n          const kids = flatten(children);\n          (self as UIComponent<any>).append(...kids as any);\n          return self;\n        });\n    (base as any).__hipst_callable__ = callable;\n    return callable as F;\n  };\n\n  const createInst = (): F => {\n    return templateCallable ? cloneFromTemplate() : (builder!() as F);\n  };\n\n  const makeFactory = (applies: ApplyFn[]): F => {\n    const callableFactory = ((...children: any[]) => {\n      let inst = createInst();\n      for (const apply of applies) inst = apply(inst);\n      return (inst as any)(...children) as F;\n    }) as unknown as F;\n\n    // mark as factory so append() ignores plain references\n    (callableFactory as any).__hipst_factory__ = true;\n\n    // Proxy to forward method calls into queued apply functions, returning a new factory each time\n    const proxy = new Proxy(callableFactory as any, {\n      get(target, prop, receiver) {\n        if (prop === \"__hipst_factory__\") return true;\n        const v = (sampleTarget as any)[prop];\n        if (typeof v === \"function\") {\n          return (...args: any[]) => makeFactory([...applies, (instCallable: F) => {\n            const t = (instCallable as any).__hipst_target__ as UIComponent<any, any, any>;\n            const out = (t as any)[prop](...args);\n            // If method returns a callable (e.g., define), switch to it; else keep current callable\n            return typeof out === \"function\" ? (out as F) : instCallable;\n          }]);\n        }\n        return Reflect.get(target, prop, receiver);\n      },\n    });\n\n    return proxy as F;\n  };\n\n  return makeFactory([]);\n}\n",
    "import { HtmlRoot } from \"./factory\";\nimport { UIComponent } from \"./comp\";\nimport type { UIContext, StateCtx, PropsCtx } from \"./context\";\nimport { resolveValue, type ValueOrFn } from \"../context\";\nimport { effect, track, type Eff, stop } from \"./reactive\";\nimport { unwrap } from \"../util\";\n\nconst ATTR_CACHE = new WeakMap<HTMLElement, Map<string, string | null>>();\nconst STYLE_CACHE = new WeakMap<HTMLElement, Map<string, string | number>>();\nconst TEXT_CACHE = new WeakMap<Node, string>();\nconst EFFECTS_SYM: unique symbol = Symbol.for(\"__hipst_effects__\");\n\ntype NodeWithEffects = { [k in typeof EFFECTS_SYM]?: Set<Eff> };\nfunction regEffect(node: Node, e: Eff) {\n  const effNode = node as unknown as NodeWithEffects;\n  let set = effNode[EFFECTS_SYM];\n  if (!set) { set = new Set<Eff>(); effNode[EFFECTS_SYM] = set; }\n  set.add(e);\n}\n\nfunction setAttr(el: HTMLElement, name: string, v: unknown) {\n  let val: string | null;\n  if (v === undefined || v === null || v === false) val = null;\n  else if (v === true) val = \"\";\n  else val = String(v);\n  const cache = ATTR_CACHE.get(el) || (ATTR_CACHE.set(el, new Map()), ATTR_CACHE.get(el)!);\n  const prev = cache.get(name);\n  if (prev === val) return;\n  cache.set(name, val);\n  if (val === null) el.removeAttribute(name);\n  else el.setAttribute(name, val);\n}\n\nfunction setStyle(el: HTMLElement, key: string, v: unknown) {\n  const style = el.style as unknown as Record<string, string | number>;\n  const next: string | number = (v === undefined || v === null || v === false) ? \"\" : (v as string | number);\n  const cache = STYLE_CACHE.get(el) || (STYLE_CACHE.set(el, new Map()), STYLE_CACHE.get(el)!);\n  const prev = cache.get(key);\n  if (prev === next) return;\n  cache.set(key, next);\n  style[key] = next;\n}\n\ntype LooseObj = Record<string, unknown>;\nfunction mountComponent<T extends string, S extends object, P extends object>(\n  nodeIn: UIComponent<T, S, P>,\n  container: HTMLElement,\n  root: UIComponent<string, LooseObj, LooseObj>\n): HTMLElement {\n  const node = unwrap(nodeIn) as UIComponent<T, S, P>;\n  const el = document.createElement(node.tag);\n\n  const baseCtx: UIContext<UIComponent<T, S, P>, S, P> = {\n    self: node,\n    parent: node.parent as unknown as UIComponent<string, LooseObj, LooseObj> | undefined,\n    root,\n    element: el as any,\n    state: node.state as unknown as StateCtx<S>,\n    props: node.props as PropsCtx<P>,\n    styles: node.styles,\n    attributes: node.attributes,\n    children: [] as unknown[],\n  } as any;\n  // children should be reactive when accessed inside effect/value functions\n  Object.defineProperty(baseCtx, \"children\", {\n    configurable: true,\n    enumerable: true,\n    get() {\n      track((node as unknown as object), \"__call_args__\");\n      const raw = (((node as any)._callArgs) ?? []) as unknown[];\n      // Unwrap callable proxies; do not execute function children here\n      return raw.map((v: any) => unwrap(v));\n    }\n  });\n  const ctx = baseCtx;\n\n  // attributes: track keys and values, apply all each run, and remove deleted ones\n  const rawAttrs: Record<string, unknown> = ((node as unknown) as { _attrsStore?: Record<string, unknown> })._attrsStore ?? {};\n  {\n    const runner = effect(() => {\n      track(rawAttrs, \"__keys__\");\n      const seen = new Set<string>();\n      for (const [name, raw] of Object.entries(rawAttrs)) {\n        seen.add(name);\n        track(rawAttrs, name);\n        const v = resolveValue(ctx, raw as ValueOrFn<unknown, UIContext<UIComponent<T, S, P>, S, P>>);\n        setAttr(el, name, v);\n      }\n      const cache = ATTR_CACHE.get(el) || (ATTR_CACHE.set(el, new Map()), ATTR_CACHE.get(el)!);\n      for (const key of Array.from(cache.keys())) {\n        if (!seen.has(key)) setAttr(el, key, null);\n      }\n    });\n    regEffect(el, runner);\n  }\n\n  // styles: track keys and values, apply all each run, and clear removed ones\n  const rawStyles: Record<string, unknown> = ((node as unknown) as { _stylesStore?: Record<string, unknown> })._stylesStore ?? {};\n  {\n    const runner = effect(() => {\n      track(rawStyles, \"__keys__\");\n      const seen = new Set<string>();\n      for (const key of Object.keys(rawStyles)) {\n        seen.add(key);\n        track(rawStyles, key);\n        const v = resolveValue(ctx, rawStyles[key] as ValueOrFn<unknown, UIContext<UIComponent<T, S, P>, S, P>>);\n        setStyle(el, key, v);\n      }\n      const cache = STYLE_CACHE.get(el) || (STYLE_CACHE.set(el, new Map()), STYLE_CACHE.get(el)!);\n      for (const k of Array.from(cache.keys())) {\n        if (!seen.has(k)) setStyle(el, k, \"\");\n      }\n    });\n    regEffect(el, runner);\n  }\n\n  // events\n  const events: Record<string, Array<(c: UIContext<UIComponent<T, S, P>, S, P>, ev?: Event) => unknown>> =\n    (((node as unknown) as { _events?: Record<string, Array<(c: UIContext<UIComponent<T, S, P>, S, P>, ev?: Event) => unknown>> })._events) ?? {};\n  for (const [evt, fns] of Object.entries(events)) {\n    if (!Array.isArray(fns)) continue;\n    el.addEventListener(evt, (ev: Event) => {\n      const callCtx = ctx;\n      for (const fn of fns) fn(callCtx, ev);\n    });\n  }\n\n  // user-defined effects registered via UIComponent.effect()\n  {\n    const list: Array<(c: UIContext<UIComponent<T, S, P>, S, P>) => void> = (((node as any)._effects) ?? []) as any;\n    for (const fn of list) {\n      const runner = effect(() => { fn(ctx); });\n      regEffect(el, runner);\n    }\n  }\n\n  // children: fully reactive list\n  {\n    const runner = effect(() => {\n      const childStore = ((node as unknown) as { _children: Array<unknown> })._children;\n      track(childStore, \"__list__\");\n      // Remove current children and clean up their effects\n      while (el.firstChild) {\n        cleanupSubtree(el.firstChild);\n        el.removeChild(el.firstChild);\n      }\n      for (const child of childStore) {\n        const real = unwrap(child);\n        if (real instanceof UIComponent) {\n          // mountComponent handles appending to container\n          mountComponent(real as UIComponent<string, LooseObj, LooseObj>, el, root);\n        } else if (typeof child === \"function\") {\n          const text = document.createTextNode(\"\");\n          el.appendChild(text);\n          const tr = effect(() => {\n            const s = String(((child as unknown as (c: UIContext<UIComponent<T, S, P>, S, P>) => unknown)(ctx)) ?? \"\");\n            const prev = TEXT_CACHE.get(text);\n            if (prev !== s) {\n              TEXT_CACHE.set(text, s);\n              text.data = s;\n            }\n          });\n          regEffect(text, tr);\n        } else {\n          el.appendChild(document.createTextNode(String(child)));\n        }\n      }\n    });\n    regEffect(el, runner);\n  }\n\n  container.appendChild(el);\n  return el;\n}\n\nfunction cleanupSubtree(node: Node) {\n  const effNode = node as unknown as NodeWithEffects;\n  const effs = effNode[EFFECTS_SYM];\n  if (effs) {\n    for (const e of effs) stop(e);\n    effNode[EFFECTS_SYM] = undefined;\n  }\n  const kids = node.childNodes;\n  for (let i = 0; i < kids.length; i++) cleanupSubtree(kids[i] as Node);\n}\n\nexport function mount(rootNode: HtmlRoot | UIComponent<string, LooseObj, LooseObj>, container: HTMLElement) {\n  // Clear SSR/previous hipst content before mounting to avoid duplicate DOM and leak effects\n  // Clean up any effects registered on the container and its subtree\n  cleanupSubtree(container);\n  while (container.firstChild) {\n    cleanupSubtree(container.firstChild);\n    container.removeChild(container.firstChild);\n  }\n  const maybe = unwrap(rootNode) as HtmlRoot | UIComponent<string, LooseObj, LooseObj>;\n  if (maybe instanceof HtmlRoot) {\n    // Head management (title/meta)\n    const r = maybe as HtmlRoot;\n    const ctx: UIContext<HtmlRoot> = {\n      self: r,\n      parent: undefined,\n      root: r,\n      element: undefined,\n      state: r.state as unknown as StateCtx<{}>,\n      props: r.props as PropsCtx<{}>,\n      styles: r.styles,\n      attributes: r.attributes,\n      children: [],\n    };\n    const title = r.headTitle;\n    if (title) {\n      const runner = effect(() => {\n        const v = resolveValue(ctx, title as ValueOrFn<string, UIContext<HtmlRoot>>);\n        if (typeof document !== \"undefined\") document.title = String(v ?? \"\");\n      });\n      // Register on container so it is cleaned up on next mount\n      regEffect(container, runner);\n    }\n    // metas could be handled similarly if needed\n\n    // Body children\n    for (const c of (r.children as unknown as Array<unknown>)) {\n      const real = unwrap(c);\n      if (real instanceof UIComponent) mountComponent(real as UIComponent<string, LooseObj, LooseObj>, container, (r as unknown) as UIComponent<string, LooseObj, LooseObj>);\n      else if (typeof c === \"function\") {\n        const text = document.createTextNode(\"\");\n        container.appendChild(text);\n        const runner = effect(() => {\n          const s = String(((c as unknown as (cx: UIContext<HtmlRoot>) => unknown)(ctx)) ?? \"\");\n          const prev = TEXT_CACHE.get(text);\n          if (prev !== s) {\n            TEXT_CACHE.set(text, s);\n            text.data = s;\n          }\n        });\n        regEffect(text, runner);\n      } else {\n        container.appendChild(document.createTextNode(String(c)));\n      }\n    }\n    return;\n  }\n  const realRoot = ((maybe as unknown as { root?: UIComponent<string, LooseObj, LooseObj> }).root) ?? maybe;\n  mountComponent(maybe, container, realRoot);\n}\n"
  ],
  "mappings": "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",
  "debugId": "9E7B5065715FE61264756E2164756E21",
  "names": []
}